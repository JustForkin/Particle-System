#include "Vector.h"
#include <math.h>

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
Vector::Vector() {

	this->x = 0;
	this->y = 0;
	this->z = 0;
}

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
Vector::Vector(Vector& v) {

	this->x = v.x;
	this->y = v.y;
	this->z = v.z;
}

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
Vector::Vector(double x, double y, double z) {

	this->x = x;
	this->y = y;
	this->z = z;
}

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
void Vector::set(double x, double y, double z) {

	this->x = x;
	this->y = y;
	this->z = z;
}

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
void Vector::set(Vector& v) {

	this->set(v.x, v.y, v.z);
}

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
double Vector::getX() {

	return x;
}

double Vector::getY() {

	return y;
}

double Vector::getZ() {

	return z;
}

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
double Vector::magnitude() {

	return sqrt(x * x + y * y + z * z);
}

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
 Vector Vector::asUnitVector () {

    double m = this->magnitude();

    Vector v(x/m, y/m, z/m);

	return v;
}

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
Vector Vector::scaled(double scaleFactor) {

	double m = this->magnitude();

     Vector v(
		 x * scaleFactor / m,
		 y * scaleFactor / m,
		 z * scaleFactor / m);

	 return v;
}

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
void Vector::multiply(double scaleFactor) {

	x *= scaleFactor;
    y *= scaleFactor;
    z *= scaleFactor;
}

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
void Vector::add(const Vector& v) {

	x += v.x;
	y += v.y;
    z += v.z;
}

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
Vector Vector::vectorTo(const Vector& v) {

	 Vector res(v.x - x, v.y - y, v.z - z);

	 return res;
}

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
bool Vector::withinSphere (Vector* center, double radius) {

	double magnitudeSqr =
      (x - center->x) * (x - center->x) +
      (y - center->y) * (y - center->y) +
      (z - center->z) * (z - center->z);

    return magnitudeSqr < radius * radius;
}

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
Vector Vector::copy() {

	Vector v(x, y, z);

	return v;
}

///////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////
Vector Vector::fromArray(double* data) {

	Vector v(data[0], data[1], data[2]);

	return v;
}
